# 데이터베이스 면접 질문 정리

---

### 데이터베이스 관련 용어

- 릴레이션 = 테이블
  
  - 하나의 릴레이션은 현실 세계의 개체(entity)를 표현 
  
  - 이 개체는 사물일수도 있고 추상적인 개념일 수도 있다
  
  - 관계형 데이터베이스에서 정보를 구분하여 저장하는 기본 단위

- 속성 (attribute)
  
  - 개체를 표현하는 항목들
  
  - 예를들어 직원 개체의 속성으로는 부서번호, 사원번호, 이름, 주소, 나이 등이 있다
  
  - 하나의 열은 하나의 속성정보를 나타낸다

- 차수 (degree)
  
  - 한 릴레이션에 들어있는 애트리뷰트의 수
  
  - 유효한 릴레이션의 최소 차수는 1 (즉, 모든 릴레이션은 적어도 하나의 속성값을 가진다)

- 튜플 (tuple) = 레코드
  
  - 릴레이션의 각 행을 튜플 또는 레코드라고 한다.

- 카디날리티 (cadinality)
  
  - 릴레이션 튜플의 갯수
  
  - 0일 수 있다 (아직 데이터가 없는 테이블이 있을 수 있기 때문에)
  
  - 카디날리티는 시간에 따라 계속 값이 변한다

- 도메인 (domain)
  
  - 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값들의 집합

<br>

### 물리적 데이터베이스 설계

---

- 한 릴레이션을 구성하는 레코드들의 모임이 화일(블록들의 모임)에 저장된다

- 한 화일을 구성하는 여러 블록이 물리적으로 인접해서 저장될 필요는 없다.  

- 블록이 흩어져 있는데 같은 파일을 구성하는지 어떻게 알아? -> 다음 블록을 가리키는 포인터를 가지고 있다 (LinkedList)

<br>

- 고정길이 레코드 vs 가변길이 레코드
  
  - 고정길이 레코드는 i번째 레코드에 접근할 때 n(i-1)+1 위치의 레코드를 읽으면 된다
  
  - 고정길이 레코드는 한 레코드를 삭제할 경우 맨 뒤에 있는 레코드 하나를 삭제된 위치로 옮길수 있다. (길이가 동일하기 때문에)

<br>

- 화일 내의 클러스터링 (intra-file clustering)
  
  - 한 파일 내에서 함께 검색될 가능성이 높은 레코드들을 디스크 상에서 물리적으로 가까운 곳에 모아두는 것            

- 화일 간의 클러스터링 (inter-file clustering)
  
  - 논리적으로 연관되어 함께 검색될 가능성이 높은 두개 이상의 화일에 속한 레코드들을 디스크 상에서 물리적으로 가까운 곳에 저장하 는 것         

<br>

### 인덱스

---

- clustered index
  
  - 탐색키값에 따라 데이터가 정렬되어있다.
  
  - 희소 인덱스로 만들 수 있다.
  
  - 범위 검색에 유리
  
  - 테이블당 한개만 만들 수 있다.

- nonclustered index
  
  - 탐색키값에 따라 데이터가 정렬되어있지 않다.
  
  - 밀집 인덱스만 만들 수 있다.
  
  - 테이블 하나에 여러개의 인덱스를 만들 수 있다. 

<br>

- 다수의 애트리뷰트를 사용해서 인덱스를 정의할 때
  
  - ex) (DNO,SALARY)를 사용해서 인덱스를 만들 때, SALARY만 이용한 질의에서는 이 인덱스를 사용할 수 없다.
  
  - 쿼리문을 수행할 때 인덱스를 사용할 지 여부는 DBMS가 결정

<br>

- 인덱스의 장점과 단점
  
  - 장점 : 검색 속도 향상
  
  - 단점 : 인덱스 생성을 위한 추가 공간 필요 / 삽입,삭제,수정 연산의 속도 저하 (인덱스 유지에 따른 오버헤드)

<br>

- B+트리
  -

<br>

### 릴레이션 정규화 (Normalization)

---

- <b>정규화</b>
  
  - 정규화 (릴레이션 분해, decompose)를 통해 데이터 중복을 줄여 데이터 갱신 이상 (update anomaly)을 최소화한다.
  
  - 정규형의 종류 => 제1 정규형 , 제 2 정규형, 제 3 정규형, BCNF(Boyce-Codd normal form), 제4 정규형, 제 5 정규형
  
  - 릴레이션 분해 => 조인 질의 필요해짐, 원래 릴레이션 재구성 못하는 문제 등이 생길 수 있음 

<br>

- <b>함수 종속성 (Funtional Dependency)</b>
  
  - 어떤 애트리뷰트 값이(x) 다른 애트리뷰트의 값을(y) 고유하게 결정한다 (x->y) . 이때 x는 y의 <b>결정자 (determinant)</b>

- 완전 함수 종속
  
  - 종속자가 기본키에만 종속되며, 기본키가 여러 속성으로 구성된 경우 기본키를 구성하는 모든 속성이 포함된 부분집합에 종속

- 부분 함수 종속
  
  - 종속자가 기본키가 아닌 다른 속성에 종속되거나, 기본키가 여러 속성으로 구성된 경우 기본키를 구성하는 속성 중 일부에만 종속

- 이행적 함수 종속
  
  - x,y,z 라는 속성이 존재할 때,  x->y , y->z 종속관계가 있고 x->z가 성립될 때 

<br>

- **제 1 정규형**
  
  - 모든 애트리뷰트가 **원자값**만을 갖는다 

- **제 2 정규형**
  
  - 제 1 정규형을 만족하면서
  
  - 모든 애트리뷰트가 **기본키에 완전 함수 종속**한다

- **제 3 정규형**
  
  - 제 2 정규형을 만족하면서
  
  - 키가 아닌 **모든 애트리뷰트가 기본키에 이행적으로 종속하지 않는** 것 
  
  - (<u>학번</u>, 학과 이름, 학과 전화번호) 속성을 가질 때,  학번 -> 학과 이름 / 학과 이름 -> 학과 전화번호 / 학번 -> 학과 전화번호  => 제 3 정규형 만족 x

- **BCNF (Boyce-Codd Normal Form)**
  
  - 제 3 정규형을 만족하면서
  
  - 기본키도 아니고 후보키도 아닌 애트리뷰트가 다른 애트리뷰트를 결정하는 경우가 없을 때 => 즉, **모든 결정자가 후보키**여야한다. 

<br>

- 역정규화 (denormalization)
  
  - 중복 및 갱신 이상을 대가로 치르면서 성능상의 요구를 만족시키기도 함 (검색 질의의 비율이 갱신 질의의 비율보다 높을 때)

<br>

### 뷰 (View)

---

- virtual relation, derived realtion (유도된 릴레이션)

- 뷰는 릴레이션으로부터 데이터를 검색하거나 갱신할 수 있는 동적인 창 역할 (dynamic window)

- 뷰의 장점 => **<u>보안, 데이터 독립성, 데이터무결성</u>**
  
  - 사용자에게 필요한 속성들만 보이게 함으로 **보안** 수준을 높일 수 있다.
  
  - 뷰는 **데이터 무결성**을 보장하는데 활용된다
    
    - 뷰에 대한 업데이트는 최소한 뷰에 조건을 위배해서는 안된다.
    
    - `WITH CHECK OPTION` : 뷰 갱신할 때 뷰를 정의하는 SELECT문의 WHERE절의 기준에 맞지 않으면 갱신 허용하지 않음
  
  -  뷰는 데이터 **독립성**을 제공한다
    
    - base 릴레이션에 직접 접근하는 쿼리가 아니라 뷰를 만들어서 접근하면, 나중에 base 릴레이션이 두개의 릴레이션으로 나눠져 검색할때 조인을 해야하더라도 뷰만 수정하면 되고, 검색쿼리는 수정하지 않아도 된다 => 독립성

<br>

- 뷰의 갱신
  
  - 뷰에 대한 갱신도 기본 릴레이션에 대해 성공적으로 수행될 수 있나? 
  
  - 갱신이 불가능 한 뷰
    
    - 한 릴레이션 위에서 정의된 뷰라도 릴레이션의 기본키를 포함하지 않은 뷰
    
    - 기본 릴레이션의 애트리뷰트 중에서 뷰에 포함되지 않은 애트리뷰트에 대해 NOT NULL 이 지정되어 있을 때
    
    - 집단 함수가 포함된 뷰
    
    - 조인으로 정의된 뷰

<br>

### 트랜잭션

---

- 트랜잭션(Transaction)이란? 
  
  - 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 

<br>

- **트랜잭션의 특성** => **<u><mark>ACID</mark></u>**
  
  - <mark>**원자성 (Atomicity)**</mark>
    
    - All or Nothing
    
    - 로그 데이터를 기록함으로써 장애 발생시 rollback
  
  - **<mark>일관성 (Consistency)</mark>**
    
    - 트랜잭션이 수행되기 전, 수행된 후 는 데이터베이스는 일관적 상태를 가진다.
    
    - 트랜잭션이 수행되는 중간에는 일시적 불일치 상태일 수 있다. 
  
  - **<mark>고립성 (Isolation)</mark>**
    
    - 한 트랜잭션이 수행되는 동안 갱신중인 데이터를 다른 트랜잭션이 접근할 수 없다.
    
    - DBMS는 다양한 고립수준 (isolation level)을 제공한다.
  
  - **<mark>지속성 (Durability)</mark>**
    
    - 한 트랜잭션이 완료되면 갱신된 내용은 시스템 장애가 발생하더라도 손실되지 않는다. 

<br>

- 트랜잭션의 완료 ( Commit ) / 트랜잭션의 철회 ( Rollback )

<br>

- 동시성 제어를 하지 않고 다수의 트랜잭션을 동시에 수행할 때 생기는 문제
  
  - **lost update**
    
    - 수행 중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮으 씀으로써 갱신이 무효가 되는 것
  
  - **dirty read**
    
    - 완료되지 않은 트랜잭션이 갱신한 데이터를 읽는 것
  
  - **unrepeatable read**
    
    - 한 트랜잭션이 동일한 데이터를 두 번 읽을 때 서로 다른 값을 읽는 것

<br>
